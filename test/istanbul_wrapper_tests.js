'use strict';

const
    IstanbulWrapper = require('../lib/istanbul_wrapper.js'),
    rimraf = require('rimraf'),
    kill = require('tree-kill'),
    assert = require('assert'),
    spawn = require('child_process').spawn,
    path = require('path'),
    fs = require('fs');

// an instance of IstanbulWrapper
let iw = null;

// during usage, tmp directory is generated by grunt in tasks/appc_istanbul.js;
// for testing, appc new will create the tmp folder
const
    DUMMY_DIR = path.join(process.cwd(), 'tmp'),
    APP_JS = path.join(DUMMY_DIR, 'app.js');

describe('new IstanbulWrapper()', function () {
    before(function () {
        // create an instance of IstanbulWrapper
        iw = new IstanbulWrapper();
    });

    it('instance of IstanbulWrapper should be an object', function () {
        assert.ok(iw, 'instance is "null" or something falsy.');
        assert.strictEqual(typeof iw, 'object', 'instance is not an object.');
    });
});

describe('instrument()', function() {
    before('create dummy arrow app.', function (done) {
        // it takes a while to create an arrow project; disable timeout
        this.timeout(0);

        // create a dummy arrow app
        const
            args = [
                'new',
                '-t', 'arrow',
                '--name', 'dummy',
                '--project-dir', `${DUMMY_DIR}`
            ],
            appcNewCmd = spawn('appc', args);
        appcNewCmd.stdout.on('data', function (output) {
            // NOTE: for debugging, uncomment
            // console.log(output.toString());
        });
        appcNewCmd.stderr.on('data', function (output) {
            // NOTE: for debugging, uncomment
            // console.log(output.toString());
        });
        appcNewCmd.on('close', function () {
            done();
        });
    });

    it('should instrument specified files', function () {
        const beforeInstrument = fs.readFileSync(APP_JS, {encoding: 'utf8'});
        iw.instrument(APP_JS, APP_JS);
        const afterInstrument = fs.readFileSync(APP_JS, {encoding: 'utf8'});

        assert.notStrictEqual(beforeInstrument, afterInstrument, 'app.js file was not instrumented.');
    });
});

describe('injectCapture()', function() {
    it('should inject capture code', function () {
        iw.injectCapture();
        const
            afterInject = fs.readFileSync(APP_JS, {encoding: 'utf8'}),
            found = new RegExp(`${iw.coverageJson}`, 'g', 'm').test(afterInject);

        assert.ok(found, 'could not find injection code.');
    });
});

describe('runArrow()', function() {
    // disable timeout
    this.timeout(0);
    it('should run arrow project and generate child.pid file', function (done) {
        iw.runArrow('server started on port 8080', function () {
            try {
                fs.statSync('child.pid');
            }
            catch (err) {
                assert.ifError(err);
            }
            done();
        });
    });
});

describe('gatherCoverage()', function() {
    it('should generate coverage.json file', function (done) {
        const somePid = fs.readFileSync('child.pid', {encoding: 'utf8'});
        // need to trigger SIGINT in order to gather code coverage data
        kill(somePid, 'SIGINT', function (err) {
            if (err) {
                assert.ifError(err);
            }

            iw.gatherCoverage();
            try {
                fs.statSync(iw.coverageJson);
            }
            catch (err) {
                assert.ifError(err);
            }
            done();
        });
    });
});

describe('makeReport()', function() {
    const COVERAGE_DIR = path.join(process.cwd(), 'coverage');

    after('cleanup', function (done) {
        console.log('--- cleanup ---');

        // it also takes a while to delete an arrow project from platform; extend timeout to 3 seconds
        this.timeout(1000 * 3);

        // delete the dummy app from 360 platform
        const appcRmCmd = spawn('appc', ['cloud', 'remove', 'dummy']);
        appcRmCmd.stdout.on('data', function (output) {
            console.log(output.toString());
        });
        appcRmCmd.stderr.on('data', function (output) {
            console.log(output.toString());
        });
        appcRmCmd.on('close', function () {
            // delete the dummy app from your local machine
            rimraf(DUMMY_DIR, function () {
                // delete the child.pid file
                rimraf('child.pid', function () {
                    done();
                });
            });
        });
    });

    afterEach(`delete ${COVERAGE_DIR}`, function (done) {
        rimraf(COVERAGE_DIR, function () {
            done();
        });
    });

    it('should create an html report by default', function () {
        iw.makeReport(null, COVERAGE_DIR);
        reportsExist([
            path.join(COVERAGE_DIR, 'index.html')
        ]);
    });

    it('should create an lcov and html report', function () {
        iw.makeReport({htmlLcov: true}, COVERAGE_DIR);
        reportsExist([
            path.join(COVERAGE_DIR, 'lcov.info'),
            path.join(COVERAGE_DIR, 'lcov-report', 'index.html')
        ]);
    });

    it('should create an lcov only report', function () {
        iw.makeReport({lcovOnly: true}, COVERAGE_DIR);
        reportsExist([
            path.join(COVERAGE_DIR, 'lcov.info')
        ]);
    });

    it('should create an cobertura report', function () {
        iw.makeReport({cobertura: true}, COVERAGE_DIR);
        reportsExist([
            path.join(COVERAGE_DIR, 'cobertura-coverage.xml')
        ]);
    });

    function reportsExist(reportPaths) {
        try {
            reportPaths.forEach(function (aReport) {
                fs.statSync(aReport);
            });
        }
        catch (err) {
            assert.ifError(err);
        }
    }
});