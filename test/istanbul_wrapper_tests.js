'use strict';

const
    IstanbulWrapper = require('../lib/istanbul_wrapper.js'),
    rimraf = require('rimraf'),
    assert = require('assert'),
    spawn = require('child_process').spawn,
    path = require('path'),
    fs = require('fs');

let iw = null;

// during usage, tmp directory is generated by grunt in tasks/appc_istanbul.js;
// for testing, appc new will create the tmp folder
const
    DUMMY_DIR = path.join(process.cwd(), 'tmp'),
    APP_JS = path.join(DUMMY_DIR, 'app.js');

describe('new IstanbulWrapper()', function () {
    before(function () {
        // create an instance of IstanbulWrapper
        iw = new IstanbulWrapper();
    });

    it('instance of IstanbulWrapper should be an object', function () {
        assert.ok(iw, 'instance is "null" or something falsy.');
        assert.strictEqual(typeof iw, 'object', 'instance is not an object.');
    });
});

describe('instrument()', function() {
    before('create dummy arrow app.', function (done) {
        // it takes a while to create an arrow project; disable timeout
        this.timeout(0);

        // create a dummy arrow app
        const
            args = [
                'new',
                '-t', 'arrow',
                '--name', 'dummy',
                '--project-dir', `${DUMMY_DIR}`
            ],
            appcNewCmd = spawn('appc', args);
        appcNewCmd.stdout.on('data', function (output) {
            console.log(output.toString());
        });
        appcNewCmd.stderr.on('data', function (output) {
            console.log(output.toString());
        });
        appcNewCmd.on('close', function () {
            done();
        });
    });

    it('should instrument specified files', function () {
        const beforeInstrument = fs.readFileSync(APP_JS, {encoding: 'utf8'});
        iw.instrument(APP_JS, APP_JS);
        const afterInstrument = fs.readFileSync(APP_JS, {encoding: 'utf8'});

        assert.notStrictEqual(beforeInstrument, afterInstrument, 'app.js file was not instrumented.');
    });
});

describe('injectCapture()', function() {
    it('should inject capture code', function () {
        iw.injectCapture();
        const
            afterInject = fs.readFileSync(APP_JS, {encoding: 'utf8'}),
            found = new RegExp(`${iw.coverageJson}`, 'g', 'm').test(afterInject);

        assert.ok(found, 'could not find injection code.');
    });
});

describe('runArrow()', function() {
    // disable timeout
    this.timeout(0);
    it('should run arrow project', function (done) {
        iw.runArrow('server started on port 8080', function () {
            try {
                fs.readFileSync('child.pid');
            }
            catch (err) {
                assert.ifError(err);
            }
            done();
        });
    });
});

describe('gatherCoverage()', function() {
    it.skip('should generate coverage.json file');
});

describe.skip('makeReport()', function() {
    after('delete dummy arrow app.', function (done) {
        // it also takes a while to delete an arrow project from platform; extend timeout to 3 seconds
        this.timeout(1000 * 3);

        // delete the dummy app from 360 platform
        const appcRmCmd = spawn('appc', ['cloud', 'remove', 'dummy']);
        appcRmCmd.stdout.on('data', function (output) {
            console.log(output.toString());
        });
        appcRmCmd.stderr.on('data', function (output) {
            console.log(output.toString());
        });
        appcRmCmd.on('close', function () {
            // and delete the dummy app from your local machine
            rimraf(DUMMY_DIR, function () {
                done();
            });
        });
    });

    it.skip('should create an html report by default');
    it.skip('should create an lcov and html report');
    it.skip('should create an lcov only report');
    it.skip('should create an cobertura report');
});